# Get around R CMD check note: Found the following possibly unsafe calls:
# Maybe move all patch commands in a seperate package, that doesn't go to
# CRAN and therefore doesn't need to fix all R CMD check notes.
# unlockBinding("cachedFuncWithFile", shiny_env)
# unlockBinding("loadSupport", shiny_env)
unlock_binding <- function(sym, env) {
  do.call(unlockBinding, list(sym, env))
}

patch_pkgload <- function() {
  trace_func_entry()
  # Changes pkgload::load_all so that it doesn't lock the environment anymore.
  # This allows to use devtools::load_all(reset=FALSE), which is less accurate
  # than devtools::load_all(), but much faster.
  pkgload_env <- environment(pkgload::load_all)
  unlock_binding("load_all", pkgload_env)
  body(pkgload_env$load_all) <- body(load_all_patched)
  lockBinding("load_all", pkgload_env)
}

load_all_patched <- local({
  # Fixes for: load_all_patched: no visible global function definition for
  `%:::%` <- function(...) NULL
  clear_cache <- function(...) NULL
  create_ns_env <- function(...) NULL
  env_bind <- function(...) NULL
  insert_global_shims <- function(...) NULL
  insert_imports_shims <- function(...) NULL
  is_foreign_method <- function(...) NULL
  is_loaded <- function(...) NULL
  load_all_quiet <- function(...) NULL
  load_code <- function(...) NULL
  load_data <- function(...) NULL
  load_depends <- function(...) NULL
  load_dll <- function(...) NULL
  load_imports <- function(...) NULL
  load_po <- function(...) NULL
  model <- function(...) NULL
  ns_env <- function(...) NULL
  ns_s3_methods <- function(...) NULL
  patched_cached_func_with_file <- function(...) NULL
  patched_load_support <- function(...) NULL
  penv <- function(...) NULL
  pkg_desc <- function(...) NULL
  pkg_name <- function(...) NULL
  pkg_path <- function(...) NULL
  populate_pkg_env <- function(...) NULL
  register_s3 <- function(...) NULL
  run_ns_load_actions <- function(...) NULL
  run_pkg_hook <- function(...) NULL
  run_user_hook <- function(...) NULL
  rv <- function(...) NULL
  ses <- function(...) NULL
  setup_ns_exports <- function(...) NULL
  setup_pkg_env <- function(...) NULL
  try_load_dll <- function(...) NULL
  unregister <- function(...) NULL
  uses_testthat <- function(...) NULL
  warn_if_conflicts <- function(...) NULL
  where <- function(...) NULL
  # Source code below was generated by calling `body(pkgload::load_all)` and
  # then modified. Each modifications is put inside a block comment of the
  # following form:
  #   # MODIFICATION START
  #   if (FALSE) { <original code } else { <new code> }
  #   # MODIFICATION END
  function(path = ".",
           reset = TRUE,
           compile = NA,
           attach = TRUE,
           export_all = TRUE,
           export_imports = export_all,
           helpers = TRUE,
           attach_testthat = uses_testthat(path),
           quiet = NULL,
           recompile = FALSE,
           warn_conflicts = TRUE) {
    path <- pkg_path(path)
    package <- pkg_name(path)
    description <- pkg_desc(path)
    withr::local_envvar(c(DEVTOOLS_LOAD = package))
    quiet <- load_all_quiet(quiet, "load_all")
    if (!quiet) {
      cli::cli_inform(c(i = "Loading {.pkg {package}}"))
    }
    if (package == "compiler") {
      oldEnabled <- compiler::enableJIT(0)
      on.exit(compiler::enableJIT(oldEnabled), TRUE)
    }
    if (!dir.exists(file.path(path, "src"))) {
      compile <- FALSE
    } else if (missing(compile) && !missing(recompile)) {
      compile <- if (isTRUE(recompile)) {
        TRUE
      } else {
        NA
      }
    }
    if (isTRUE(compile)) {
      rlang::check_installed("pkgbuild", reason = "to compile packages with a `src/` directory.")
      pkgbuild::clean_dll(path)
      pkgbuild::compile_dll(path, quiet = quiet)
    } else if (identical(compile, NA)) {
      rlang::check_installed("pkgbuild", reason = "to compile packages with a `src/` directory.")
      pkgbuild::compile_dll(path, quiet = quiet)
    } else if (identical(compile, FALSE)) {
    } else {
      cli::cli_abort("{.arg compile} must be a logical vector of length 1.")
    }
    old_methods <- list()
    if (reset) {
      clear_cache()
      if (is_loaded(package)) {
        methods_env <- ns_s3_methods(package)
        unregister(package)
        old_methods <- as.list(methods_env)
        old_methods <- Filter(function(x) {
          is_foreign_method(
            x,
            package
          )
        }, old_methods)
      }
    }
    if (is_loaded(package)) {
      rlang::env_unlock(ns_env(package))
    } else {
      create_ns_env(path)
    }
    out <- list(env = ns_env(package))
    load_depends(path, quiet = quiet)
    load_imports(path)
    insert_imports_shims(package)
    out$data <- load_data(path)
    out$code <- load_code(path, quiet = quiet)
    register_s3(path)
    if (identical(compile, FALSE)) {
      out$dll <- try_load_dll(path)
    } else {
      out$dll <- load_dll(path)
    }
    if (isTRUE(attach_testthat) && package != "testthat") {
      ("base" %:::% "library")("testthat", warn.conflicts = FALSE)
    }
    load_po(package, path)
    run_pkg_hook(package, "load")
    setup_ns_exports(path)
    run_ns_load_actions(package)
    ns <- ns_env(package)
    # MODIFICATION START
    if (FALSE) {
      lockEnvironment(ns)
      for (nm in names(ns)) {
        lockBinding(nm, ns)
      }
    } else {
      # do nothing
    }
    # MODIFICATION END
    run_user_hook(package, "load")
    if (attach) {
      setup_pkg_env(package)
    }
    env_bind(ns_s3_methods(package), !!!old_methods)
    if (attach) {
      run_pkg_hook(package, "attach")
      run_user_hook(package, "attach")
      populate_pkg_env(
        package, path, export_all, export_imports,
        helpers
      )
    }
    insert_global_shims()
    if (isTRUE(warn_conflicts)) {
      warn_if_conflicts(package, out$env, globalenv())
    }
    invisible(out)
  }
})
patch_shiny <- function() {
  trace_func_entry()
  # Fixes shiny autoreload features and suppresses warning when sourcing
  # an R package as shiny app.
  shiny_env <- environment(shiny::loadSupport)
  unlock_binding("cachedFuncWithFile", shiny_env)
  body(shiny_env$cachedFuncWithFile) <- body(cachedFuncWithFilePatched)
  lockBinding("cachedFuncWithFile", shiny_env)
  unlock_binding("loadSupport", shiny_env)
  body(shiny_env$loadSupport) <- body(loadSupportPatched)
  lockBinding("loadSupport", shiny_env)
}

loadSupportPatched <- function(appDir,
                               renv = new.env(parent = globalenv()),
                               globalrenv = globalenv()) {
  # message("Entering patched version of loadSupport")
  require2 <- require # required to get around R CMD check
  require2("shiny")
  if (is.null(appDir)) {
    appDir <- findEnclosingApp(".")
  }
  descFile <- file.path.ci(appDir, "DESCRIPTION")
  if (!is.null(globalrenv)) {
    globalPath <- file.path.ci(appDir, "global.R")
    if (file.exists(globalPath)) {
      withr::with_dir(appDir, {
        sourceUTF8(basename(globalPath), envir = globalrenv)
      })
    }
  }
  helpersDir <- file.path(appDir, "R")
  disabled <- list.files(helpersDir,
    pattern = "^_disable_autoload\\.r$",
    recursive = FALSE, ignore.case = TRUE
  )
  if (length(disabled) > 0) {
    return(invisible(renv))
  }
  helpers <- list.files(helpersDir,
    pattern = "\\.[rR]$",
    recursive = FALSE,
    full.names = TRUE
  )
  helpers <- sort_c(helpers)
  helpers <- normalizePath(helpers)
  if (file.exists(descFile)) {
    # message("Calling: devtools::load_all(", appDir, ", reset = FALSE)")
    devtools::load_all(appDir, reset = FALSE, quiet = TRUE)
  } else {
    # message("Sourcing files from:", appDir)
    withr::with_dir(appDir, {
      lapply(helpers, sourceUTF8, envir = renv)
    })
  }
  invisible(renv)
}

cachedFuncWithFilePatched <- function(dir,
                                      file,
                                      func,
                                      case.sensitive = FALSE) {
  dir <- normalizePath(dir, mustWork = TRUE)
  value <- NULL
  filePattern <- getOption(
    "shiny.autoreload.pattern",
    ".*\\.(r|html?|js|css|png|jpe?g|gif)$"
  )
  last_mtimes <- NULL
  function(...) {
    file.pathfunc <- if (case.sensitive) file.path else file.path.ci
    fname <- file.pathfunc(dir, file)
    files <- list.files(dir, filePattern, recursive = TRUE, ignore.case = TRUE)
    files <- sort_c(files)
    mtimes <- file.info(files)$mtime
    names(mtimes) <- files
    if (!identical(last_mtimes, mtimes)) {
      value <<- func(fname, ...)
      last_mtimes <<- mtimes
    }
    value
  }
}

# Stubs for variables from shiny's environment
file.path.ci <- function(...) NULL
sourceUTF8 <- function(...) NULL
sort_c <- function(...) NULL
findEnclosingApp <- function(...) NULL
file.path.ci <- function(...) NULL
sourceUTF8 <- function(...) NULL
sort_c <- function(...) NULL
